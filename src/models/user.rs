use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use sqlx::FromRow;
use uuid::Uuid;
use validator::{Validate, ValidationError};

#[derive(Serialize, Deserialize, FromRow, Default, Validate)]
pub struct User {
    // `id` should be a valid UUID, but no validation needed if generated by the database.
    pub id: Option<Uuid>,

    // `tenant_id` is skipped for serialization but should still be a valid UUID when provided.
    #[serde(skip)]
    pub tenant_id: Option<Uuid>,

    // First name should be present and could have a length restriction.
    #[validate(length(
        min = 1,
        max = 50,
        message = "First name must be between 1 and 50 characters"
    ))]
    pub first_name: String,

    // Last name should be present and could have a length restriction.
    #[validate(length(
        min = 1,
        max = 50,
        message = "Last name must be between 1 and 50 characters"
    ))]
    pub last_name: String,

    // `confirmed` is a boolean field, so no validation is needed as itâ€™s either `true` or `false`.
    #[serde(skip_deserializing)]
    pub confirmed: Option<bool>,

    // `created_at` should be in the past.
    #[validate(custom(function = "validate_past_date"))]
    pub created_at: Option<DateTime<Utc>>,

    // `updated_at` should be in the past as well and ideally should be equal to or after `created_at`.
    #[validate(custom(function = "validate_past_date"))]
    pub updated_at: Option<DateTime<Utc>>,
}

// Custom validator for past dates.
fn validate_past_date(date: &DateTime<Utc>) -> Result<(), ValidationError> {
    if *date > Utc::now() {
        return Err(ValidationError::new("Date value must be in the past"));
    }

    Ok(())
}
